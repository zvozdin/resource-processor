spring:
  cloud:
    stream:
      bindings:
        onReceive-in-0:
          destination: resource-ids
          group: resource-processor
      rabbit:
        bindings:
          onReceive-in-0:
            consumer:
              # The logic of retrying is actually to use DLQ, set a default exchange to it, and after the TTL time expires, the message will be redirected to the queue corresponding to the specified exchange
              autoBindDlq: true # set to true to enable DLQ
              dlq-ttl: 5_000 # sets a dead letter message timeout, which disguises the retry interval
              dlqDeadLetterExchange: # leave it blank to set the default value. With the default value, the message in DLQ will be delivered to the quque with the corresponding name according to the value of its routingKey
              republish-to-dlq: true # to know the exact exception of the last error; will add detailed exception and exception stack information in the message header
              acknowledge-mode: manual # inject the channel into the consuming side and handle it manually
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

server:
  port: 8090
  restTemplate:
    connectTimeoutMilliSeconds: 2000
    readTimeoutMilliSeconds: 2000
    maxRetryAttempts: 2
    retryDelayMilliSeconds: 10

services:
  url:
    resource-service: http://localhost:8080/api/v1/resources
    song-service: http://localhost:8081/api/v1/songs

logging:
  level:
    root: info
